import * as ts from 'typescript';
import { SourceMapper } from './source_map_utils';
export { convertDecorators } from './decorator-annotator';
export { FileMap, ModulesManifest } from './modules_manifest';
export { EmitResult, EmitTransformers, emitWithTsickle, mergeEmitResults, TransformerHost, TransformerOptions } from './transformer';
export { Options, Pass, TsickleCompilerHost, TsickleHost } from './tsickle_compiler_host';
export interface AnnotatorHost {
    /**
     * If provided a function that logs an internal warning.
     * These warnings are not actionable by an end user and should be hidden
     * by default.
     */
    logWarning?: (warning: ts.Diagnostic) => void;
    pathToModuleName: (context: string, importPath: string) => string;
}
export interface AnnotatorOptions {
    /**
     * If true, convert every type to the Closure {?} type, which means
     * "don't check types".
     */
    untyped?: boolean;
    /** If provided, a set of paths whose types should always generate as {?}. */
    typeBlackListPaths?: Set<string>;
    /**
     * Convert shorthand "/index" imports to full path (include the "/index").
     * Annotation will be slower because every import must be resolved.
     */
    convertIndexImportShorthand?: boolean;
}
export declare enum AnnotatorFeatures {
    LowerDecorators = 1,
    /**
     * Filter out types when expanding `export * from ...`.
     *
     * Needed by the transformer version as TypeScript collects symbol information before
     * running the transformers, and the generated identifiers therefore have no
     * TypeScript symbol information associated. Because of this, Typescript does not
     * elide exports for types in this case.
     *
     * This flag will be removed and always set once we drop the on transformer version of tsickle.
     */
    FilterTypesInExportStart = 2,
    /**
     * Generated @typedefs for reexported interfaces.
     *
     * Needed for the transformer version of tsickle as the .d.ts is generated before running tsickle,
     * and therefore does no longer contain the reexports for the interfaces, even if
     * tsickle changes them into functions.
     *
     * This flag will be removed and always set once we drop the on transformer version of tsickle.
     */
    TypeDefReexportForInterfaces = 8,
    Default = 0,
    Transformer = 11,
}
/**
 * The header to be used in generated externs.  This is not included in the
 * output of annotate() because annotate() works one file at a time, and
 * typically you create one externs file from the entire compilation unit.
 */
export declare const EXTERNS_HEADER: string;
/**
 * Symbols that are already declared as externs in Closure, that should
 * be avoided by tsickle's "declare ..." => externs.js conversion.
 */
export declare let closureExternsBlacklist: string[];
export declare function formatDiagnostics(diags: ts.Diagnostic[]): string;
/** @return true if node has the specified modifier flag set. */
export declare function hasModifierFlag(node: ts.Node, flag: ts.ModifierFlags): boolean;
export declare function isDtsFileName(fileName: string): boolean;
export declare function annotate(typeChecker: ts.TypeChecker, file: ts.SourceFile, host: AnnotatorHost, options?: AnnotatorOptions, tsHost?: ts.ModuleResolutionHost, tsOpts?: ts.CompilerOptions, sourceMapper?: SourceMapper, features?: AnnotatorFeatures): {
    output: string;
    diagnostics: ts.Diagnostic[];
};
export declare function writeExterns(typeChecker: ts.TypeChecker, file: ts.SourceFile, host: AnnotatorHost, options?: AnnotatorOptions): {
    output: string;
    diagnostics: ts.Diagnostic[];
};
/** Concatenate all generated externs definitions together into a string. */
export declare function getGeneratedExterns(externs: {
    [fileName: string]: string;
}): string;
