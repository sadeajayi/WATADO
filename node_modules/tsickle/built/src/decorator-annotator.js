"use strict";
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ts = require("typescript");
var decorators_1 = require("./decorators");
var rewriter_1 = require("./rewriter");
var type_translator_1 = require("./type-translator");
var util_1 = require("./util");
// DecoratorClassVisitor rewrites a single "class Foo {...}" declaration.
// It's its own object because we collect decorators on the class and the ctor
// separately for each class we encounter.
var DecoratorClassVisitor = (function () {
    function DecoratorClassVisitor(typeChecker, rewriter, classDecl, importedNames) {
        this.typeChecker = typeChecker;
        this.rewriter = rewriter;
        this.classDecl = classDecl;
        this.importedNames = importedNames;
        if (classDecl.decorators) {
            var toLower = this.decoratorsToLower(classDecl);
            if (toLower.length > 0)
                this.decorators = toLower;
        }
    }
    /**
     * Determines whether the given decorator should be re-written as an annotation.
     */
    DecoratorClassVisitor.prototype.shouldLower = function (decorator) {
        for (var _i = 0, _a = decorators_1.getDecoratorDeclarations(decorator, this.typeChecker); _i < _a.length; _i++) {
            var d = _a[_i];
            // Switch to the TS JSDoc parser in the future to avoid false positives here.
            // For example using '@Annotation' in a true comment.
            // However, a new TS API would be needed, track at
            // https://github.com/Microsoft/TypeScript/issues/7393.
            var commentNode = d;
            // Not handling PropertyAccess expressions here, because they are
            // filtered earlier.
            if (commentNode.kind === ts.SyntaxKind.VariableDeclaration) {
                if (!commentNode.parent)
                    continue;
                commentNode = commentNode.parent;
            }
            // Go up one more level to VariableDeclarationStatement, where usually
            // the comment lives. If the declaration has an 'export', the
            // VDList.getFullText will not contain the comment.
            if (commentNode.kind === ts.SyntaxKind.VariableDeclarationList) {
                if (!commentNode.parent)
                    continue;
                commentNode = commentNode.parent;
            }
            var range = ts.getLeadingCommentRanges(commentNode.getFullText(), 0);
            if (!range)
                continue;
            for (var _b = 0, range_1 = range; _b < range_1.length; _b++) {
                var _c = range_1[_b], pos = _c.pos, end = _c.end;
                var jsDocText = commentNode.getFullText().substring(pos, end);
                if (jsDocText.includes('@Annotation'))
                    return true;
            }
        }
        return false;
    };
    DecoratorClassVisitor.prototype.decoratorsToLower = function (n) {
        var _this = this;
        if (n.decorators) {
            return n.decorators.filter(function (d) { return _this.shouldLower(d); });
        }
        return [];
    };
    /**
     * gatherConstructor grabs the parameter list and decorators off the class
     * constructor, and emits nothing.
     */
    DecoratorClassVisitor.prototype.gatherConstructor = function (ctor) {
        var ctorParameters = [];
        var hasDecoratedParam = false;
        for (var _i = 0, _a = ctor.parameters; _i < _a.length; _i++) {
            var param = _a[_i];
            var ctorParam = { type: null, decorators: null };
            if (param.decorators) {
                ctorParam.decorators = this.decoratorsToLower(param);
                hasDecoratedParam = hasDecoratedParam || ctorParam.decorators.length > 0;
            }
            if (param.type) {
                // param has a type provided, e.g. "foo: Bar".
                // Verify that "Bar" is a value (e.g. a constructor) and not just a type.
                var sym = this.typeChecker.getTypeAtLocation(param.type).getSymbol();
                if (sym && (sym.flags & ts.SymbolFlags.Value)) {
                    ctorParam.type = param.type;
                }
            }
            ctorParameters.push(ctorParam);
        }
        // Use the ctor parameter metadata only if the class or the ctor was decorated.
        if (this.decorators || hasDecoratedParam) {
            this.ctorParameters = ctorParameters;
        }
    };
    /**
     * gatherMethod grabs the decorators off a class method and emits nothing.
     */
    DecoratorClassVisitor.prototype.gatherMethodOrProperty = function (method) {
        if (!method.decorators)
            return;
        if (!method.name || method.name.kind !== ts.SyntaxKind.Identifier) {
            // Method has a weird name, e.g.
            //   [Symbol.foo]() {...}
            this.rewriter.error(method, 'cannot process decorators on strangely named method');
            return;
        }
        var name = method.name.text;
        var decorators = this.decoratorsToLower(method);
        if (decorators.length === 0)
            return;
        if (!this.propDecorators)
            this.propDecorators = new Map();
        this.propDecorators.set(name, decorators);
    };
    /**
     * For lowering decorators, we need to refer to constructor types.
     * So we start with the identifiers that represent these types.
     * However, TypeScript does not allow us to emit them in a value position
     * as it associated different symbol information with it.
     *
     * This method looks for the place where the value that is associated to
     * the type is defined and returns that identifier instead.
     *
     * This might be simplified when https://github.com/Microsoft/TypeScript/issues/17516 is solved.
     */
    DecoratorClassVisitor.prototype.getValueIdentifierForType = function (typeSymbol, typeNode) {
        if (!typeSymbol.valueDeclaration) {
            return null;
        }
        var valueName = typeSymbol.valueDeclaration.name;
        if (!valueName || valueName.kind !== ts.SyntaxKind.Identifier) {
            return null;
        }
        if (valueName.getSourceFile() === this.rewriter.file) {
            return valueName;
        }
        // Need to look at the first identifier only
        // to ignore generics.
        var firstIdentifierInType = firstIdentifierInSubtree(typeNode);
        if (firstIdentifierInType) {
            for (var _i = 0, _a = this.importedNames; _i < _a.length; _i++) {
                var _b = _a[_i], name_1 = _b.name, declarationNames = _b.declarationNames;
                if (firstIdentifierInType.text === name_1.text &&
                    declarationNames.some(function (d) { return d === valueName; })) {
                    return name_1;
                }
            }
        }
        return null;
    };
    DecoratorClassVisitor.prototype.beforeProcessNode = function (node) {
        switch (node.kind) {
            case ts.SyntaxKind.Constructor:
                this.gatherConstructor(node);
                break;
            case ts.SyntaxKind.PropertyDeclaration:
            case ts.SyntaxKind.SetAccessor:
            case ts.SyntaxKind.GetAccessor:
            case ts.SyntaxKind.MethodDeclaration:
                this.gatherMethodOrProperty(node);
                break;
            default:
        }
    };
    DecoratorClassVisitor.prototype.maybeProcessDecorator = function (node, start) {
        if (this.shouldLower(node)) {
            // Return true to signal that this node should not be emitted,
            // but still emit the whitespace *before* the node.
            if (!start) {
                start = node.getFullStart();
            }
            this.rewriter.writeRange(node, start, node.getStart());
            return true;
        }
        return false;
    };
    DecoratorClassVisitor.prototype.foundDecorators = function () {
        return !!(this.decorators || this.ctorParameters || this.propDecorators);
    };
    /**
     * emits the types for the various gathered metadata to be used
     * in the tsickle type annotations helper.
     */
    DecoratorClassVisitor.prototype.emitMetadataTypeAnnotationsHelpers = function () {
        if (!this.classDecl.name)
            return;
        var className = rewriter_1.getIdentifierText(this.classDecl.name);
        if (this.decorators) {
            this.rewriter.emit("/** @type {!Array<{type: !Function, args: (undefined|!Array<?>)}>} */\n");
            this.rewriter.emit(className + ".decorators;\n");
        }
        if (this.decorators || this.ctorParameters) {
            this.rewriter.emit("/**\n");
            this.rewriter.emit(" * @nocollapse\n");
            this.rewriter.emit(" * @type {function(): !Array<(null|{type: ?, decorators: (undefined|!Array<{type: !Function, args: (undefined|!Array<?>)}>)})>}\n");
            this.rewriter.emit(" */\n");
            this.rewriter.emit(className + ".ctorParameters;\n");
        }
        if (this.propDecorators) {
            this.rewriter.emit("/** @type {!Object<string,!Array<{type: !Function, args: (undefined|!Array<?>)}>>} */\n");
            this.rewriter.emit(className + ".propDecorators;\n");
        }
    };
    /**
     * emitMetadata emits the various gathered metadata, as static fields.
     */
    DecoratorClassVisitor.prototype.emitMetadataAsStaticProperties = function () {
        var decoratorInvocations = '{type: Function, args?: any[]}[]';
        if (this.decorators) {
            this.rewriter.emit("static decorators: " + decoratorInvocations + " = [\n");
            for (var _i = 0, _a = this.decorators; _i < _a.length; _i++) {
                var annotation = _a[_i];
                this.emitDecorator(annotation);
                this.rewriter.emit(',\n');
            }
            this.rewriter.emit('];\n');
        }
        if (this.decorators || this.ctorParameters) {
            this.rewriter.emit("/** @nocollapse */\n");
            // ctorParameters may contain forward references in the type: field, so wrap in a function
            // closure
            this.rewriter.emit("static ctorParameters: () => ({type: any, decorators?: " + decoratorInvocations +
                "}|null)[] = () => [\n");
            for (var _b = 0, _c = this.ctorParameters || []; _b < _c.length; _b++) {
                var param = _c[_b];
                if (!param.type && !param.decorators) {
                    this.rewriter.emit('null,\n');
                    continue;
                }
                this.rewriter.emit("{type: ");
                if (!param.type) {
                    this.rewriter.emit("undefined");
                }
                else {
                    // For transformer mode, tsickle must emit not only the string referring to the type,
                    // but also create a source mapping, so that TypeScript can later recognize that the
                    // symbol is used in a value position, so that TypeScript emits an import for the
                    // symbol.
                    // The code below and in getValueIdentifierForType finds the value node corresponding to
                    // the type and emits that symbol if possible. This causes a source mapping to the value,
                    // which then allows later transformers in the pipeline to do the correct module
                    // rewriting. Note that we cannot use param.type as the emit node directly (not even just
                    // for mapping), because that is marked as a type use of the node, not a value use, so it
                    // doesn't get updated as an export.
                    var sym = this.typeChecker.getTypeAtLocation(param.type).getSymbol();
                    var emitNode = this.getValueIdentifierForType(sym, param.type);
                    if (emitNode) {
                        this.rewriter.writeRange(emitNode, emitNode.getStart(), emitNode.getEnd());
                    }
                    else {
                        var typeStr = new type_translator_1.TypeTranslator(this.typeChecker, param.type)
                            .symbolToString(sym, /* useFqn */ true);
                        this.rewriter.emit(typeStr);
                    }
                }
                this.rewriter.emit(", ");
                if (param.decorators) {
                    this.rewriter.emit('decorators: [');
                    for (var _d = 0, _e = param.decorators; _d < _e.length; _d++) {
                        var decorator = _e[_d];
                        this.emitDecorator(decorator);
                        this.rewriter.emit(', ');
                    }
                    this.rewriter.emit(']');
                }
                this.rewriter.emit('},\n');
            }
            this.rewriter.emit("];\n");
        }
        if (this.propDecorators) {
            this.rewriter.emit("static propDecorators: {[key: string]: " + decoratorInvocations + "} = {\n");
            for (var _f = 0, _g = util_1.toArray(this.propDecorators.keys()); _f < _g.length; _f++) {
                var name_2 = _g[_f];
                this.rewriter.emit("\"" + name_2 + "\": [");
                for (var _h = 0, _j = this.propDecorators.get(name_2); _h < _j.length; _h++) {
                    var decorator = _j[_h];
                    this.emitDecorator(decorator);
                    this.rewriter.emit(',');
                }
                this.rewriter.emit('],\n');
            }
            this.rewriter.emit('};\n');
        }
    };
    DecoratorClassVisitor.prototype.emitDecorator = function (decorator) {
        this.rewriter.emit('{ type: ');
        var expr = decorator.expression;
        switch (expr.kind) {
            case ts.SyntaxKind.Identifier:
                // The decorator was a plain @Foo.
                this.rewriter.visit(expr);
                break;
            case ts.SyntaxKind.CallExpression:
                // The decorator was a call, like @Foo(bar).
                var call = expr;
                this.rewriter.visit(call.expression);
                if (call.arguments.length) {
                    this.rewriter.emit(', args: [');
                    for (var _i = 0, _a = call.arguments; _i < _a.length; _i++) {
                        var arg = _a[_i];
                        this.rewriter.writeNodeFrom(arg, arg.getStart());
                        this.rewriter.emit(', ');
                    }
                    this.rewriter.emit(']');
                }
                break;
            default:
                this.rewriter.errorUnimplementedKind(expr, 'gathering metadata');
                this.rewriter.emit('undefined');
        }
        this.rewriter.emit(' }');
    };
    return DecoratorClassVisitor;
}());
exports.DecoratorClassVisitor = DecoratorClassVisitor;
var DecoratorRewriter = (function (_super) {
    __extends(DecoratorRewriter, _super);
    function DecoratorRewriter(typeChecker, sourceFile, sourceMapper) {
        var _this = _super.call(this, sourceFile, sourceMapper) || this;
        _this.typeChecker = typeChecker;
        _this.importedNames = [];
        return _this;
    }
    DecoratorRewriter.prototype.process = function () {
        this.visit(this.file);
        return this.getOutput();
    };
    DecoratorRewriter.prototype.maybeProcess = function (node) {
        if (this.currentDecoratorConverter) {
            this.currentDecoratorConverter.beforeProcessNode(node);
        }
        switch (node.kind) {
            case ts.SyntaxKind.ImportDeclaration:
                (_a = this.importedNames).push.apply(_a, collectImportedNames(this.typeChecker, node));
                return false;
            case ts.SyntaxKind.Decorator:
                return this.currentDecoratorConverter &&
                    this.currentDecoratorConverter.maybeProcessDecorator(node);
            case ts.SyntaxKind.ClassDeclaration:
                var oldDecoratorConverter = this.currentDecoratorConverter;
                this.currentDecoratorConverter = new DecoratorClassVisitor(this.typeChecker, this, node, this.importedNames);
                this.writeLeadingTrivia(node);
                visitClassContentIncludingDecorators(node, this, this.currentDecoratorConverter);
                this.currentDecoratorConverter = oldDecoratorConverter;
                return true;
            default:
                return false;
        }
        var _a;
    };
    return DecoratorRewriter;
}(rewriter_1.Rewriter));
/**
 * Returns the first identifier in the node tree starting at node
 * in a depth first order.
 *
 * @param node The node to start with
 * @return The first identifier if one was found.
 */
function firstIdentifierInSubtree(node) {
    if (node.kind === ts.SyntaxKind.Identifier) {
        return node;
    }
    return ts.forEachChild(node, firstIdentifierInSubtree);
}
/**
 * Collect the Identifiers used as named bindings in the given import declaration
 * with their Symbol.
 * This is needed later on to find an identifier that represents the value
 * of an imported type identifier.
 */
function collectImportedNames(typeChecker, decl) {
    var importedNames = [];
    var importClause = decl.importClause;
    if (!importClause) {
        return importedNames;
    }
    var names = [];
    if (importClause.name) {
        names.push(importClause.name);
    }
    if (importClause.namedBindings &&
        importClause.namedBindings.kind === ts.SyntaxKind.NamedImports) {
        var namedImports = importClause.namedBindings;
        names.push.apply(names, namedImports.elements.map(function (e) { return e.name; }));
    }
    for (var _i = 0, names_1 = names; _i < names_1.length; _i++) {
        var name_3 = names_1[_i];
        var symbol = typeChecker.getSymbolAtLocation(name_3);
        if (symbol.flags & ts.SymbolFlags.Alias) {
            symbol = typeChecker.getAliasedSymbol(symbol);
        }
        var declarationNames = [];
        if (symbol.declarations) {
            for (var _a = 0, _b = symbol.declarations; _a < _b.length; _a++) {
                var d = _b[_a];
                if (d.name && d.name.kind === ts.SyntaxKind.Identifier) {
                    declarationNames.push(d.name);
                }
            }
        }
        if (symbol.declarations) {
            importedNames.push({ name: name_3, declarationNames: declarationNames });
        }
    }
    return importedNames;
}
exports.collectImportedNames = collectImportedNames;
function visitClassContentIncludingDecorators(classDecl, rewriter, decoratorVisitor) {
    if (rewriter.file.text[classDecl.getEnd() - 1] !== '}') {
        rewriter.error(classDecl, 'unexpected class terminator');
        return;
    }
    rewriter.writeNodeFrom(classDecl, classDecl.getStart(), classDecl.getEnd() - 1);
    // At this point, we've emitted up through the final child of the class, so all that
    // remains is the trailing whitespace and closing curly brace.
    // The final character owned by the class node should always be a '}',
    // or we somehow got the AST wrong and should report an error.
    // (Any whitespace or semicolon following the '}' will be part of the next Node.)
    if (decoratorVisitor) {
        decoratorVisitor.emitMetadataAsStaticProperties();
    }
    rewriter.writeRange(classDecl, classDecl.getEnd() - 1, classDecl.getEnd());
}
exports.visitClassContentIncludingDecorators = visitClassContentIncludingDecorators;
function convertDecorators(typeChecker, sourceFile, sourceMapper) {
    return new DecoratorRewriter(typeChecker, sourceFile, sourceMapper).process();
}
exports.convertDecorators = convertDecorators;

//# sourceMappingURL=decorator-annotator.js.map
